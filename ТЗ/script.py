# Создадим структурированный анализ проблем и рекомендаций для Smart Tuner V2
import pandas as pd

# Список критических проблем
critical_issues = [
    {
        "категория": "База данных Optuna",
        "проблема": "SQLite блокировка при параллельных запросах",
        "серьезность": "Критическая",
        "влияние": "Полная остановка оптимизации",
        "файл": "optimization_engine.py",
        "строка": "76-82"
    },
    {
        "категория": "Очистка данных",
        "проблема": "Неполная очистка базы Optuna при запуске",
        "серьезность": "Высокая",
        "влияние": "Конфликты старых и новых исследований",
        "файл": "install.sh",
        "строка": "437-440"
    },
    {
        "категория": "Управление памятью",
        "проблема": "Утечки памяти в trials без gc.collect()",
        "серьезность": "Высокая",
        "влияние": "OOM ошибки при длительном обучении",
        "файл": "smart_tuner_main.py",
        "строка": "240-280"
    },
    {
        "категория": "Обработка ошибок",
        "проблема": "Отсутствие robust обработки NaN в метриках",
        "серьезность": "Средняя",
        "влияние": "Сбои при некорректных метриках",
        "файл": "optimization_engine.py",
        "строка": "350-420"
    },
    {
        "категория": "Параллелизм",
        "проблема": "Race conditions при одновременном доступе к конфигу",
        "серьезность": "Средняя",
        "влияние": "Непредсказуемое поведение",
        "файл": "early_stop_controller.py",
        "строка": "45-60"
    }
]

# Анализ архитектурных проблем
architectural_issues = [
    {
        "компонент": "OptimizationEngine",
        "проблема": "Отсутствие механизма восстановления после сбоев",
        "рекомендация": "Добавить checkpoint/resume функциональность"
    },
    {
        "компонент": "EarlyStopController", 
        "проблема": "Слишком агрессивные пороги для TTS",
        "рекомендация": "Использовать адаптивные пороги на основе фазы обучения"
    },
    {
        "компонент": "TrainerWrapper",
        "проблема": "Монолитная архитектура без модульности",
        "рекомендация": "Разделить на независимые модули с четкими интерфейсами"
    },
    {
        "компонент": "Config Management",
        "проблема": "Отсутствие валидации конфигурации",
        "рекомендация": "Добавить схему валидации и type hints"
    }
]

# Анализ дашбордов
dashboard_status = [
    {
        "сервис": "MLflow UI",
        "порт": 5000,
        "статус_запуска": "Работает",
        "проблемы": "Возможные конфликты портов, отсутствие проверки доступности"
    },
    {
        "сервис": "TensorBoard",
        "порт": 5001,
        "статус_запуска": "Работает", 
        "проблемы": "Не обрабатывает пустые директории логов"
    },
    {
        "сервис": "Optuna Dashboard",
        "порт": 5002,
        "статус_запуска": "Частично работает",
        "проблемы": "База данных блокируется при параллельном доступе"
    },
    {
        "сервис": "Streamlit Demo",
        "порт": 5003,
        "статус_запуска": "Работает",
        "проблемы": "Отсутствие проверки готовности моделей"
    }
]

# Создаем DataFrame для анализа
df_critical = pd.DataFrame(critical_issues)
df_arch = pd.DataFrame(architectural_issues)
df_dash = pd.DataFrame(dashboard_status)

print("=== КРИТИЧЕСКИЕ ПРОБЛЕМЫ ===")
print(df_critical.to_string(index=False))
print("\n=== АРХИТЕКТУРНЫЕ ПРОБЛЕМЫ ===")
print(df_arch.to_string(index=False))
print("\n=== СТАТУС ДАШБОРДОВ ===")  
print(df_dash.to_string(index=False))

# Сохраняем в CSV для дальнейшего анализа
df_critical.to_csv('critical_issues.csv', index=False, encoding='utf-8')
df_arch.to_csv('architectural_issues.csv', index=False, encoding='utf-8')
df_dash.to_csv('dashboard_status.csv', index=False, encoding='utf-8')

print("\n=== ФАЙЛЫ СОХРАНЕНЫ ===")
print("- critical_issues.csv")
print("- architectural_issues.csv") 
print("- dashboard_status.csv")